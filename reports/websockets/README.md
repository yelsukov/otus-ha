# Отчет по домашнему заданию "In-Memory СУБД"

## Содержание

1. [ Задача ](#task)
2. [ Архитектура проекта ](#architecture)
3. [ Код сервисов ](#code)
4. [ Масштабирование сервиса новостей ](#scaling)
5. [ Подготовка окружения ](#env-prepearings)
6. [ Тестирование ](#tests)
7. [ Выводы ](#total)

<a name="task"></a>

## Задача

Онлайн обновление ленты новостей

Цель: В результате выполнения ДЗ вы научитесь обновлять ленту новостей без перезагрузки страницы.

Необходимо разработать компонент, куда будет подключаться клиент при открытии страницы ленты. Сервис должен слушать
очередь обновлений ленты.

При получении подписанным клиентом сообщения, отправлять его в браузер по WebSocket. Учесть возможность масштабирования
сервиса, то есть сообщение должно доставляться только на тот экземпляр компонента, куда соединен клиент. Для этого можно
использовать, например Routing Key из Rabbitmq.

Требования:

- При добавлении поста у друга, лента должна обновляться автоматически (с небольшой задержкой).
- Корректная работа сервиса вебсокетов.
- Линейная масштабируемость сервиса вебсокетов.
- Описан процесс масштабирования.

<a name="architecture"></a>

## Архитектура проекта

![Архитектура сервисов](arch.svg)

### API Gateway

Доступная клиентам точка входа. На борту имеет HTTP интерфейс для REST API и прокси роут для авторизации запросов на
websocket соединение c сервисами новостей.

### MySQL

Cервер Базы Данных. Используется REST API сервисом, для хранения различных сущностей и их состояний.

В тестовом варианте состоит из master сервера и реплики.

Взаимодействие с MySQL происходит через ProxySQL, с распределением запрос на запись/чтение между master и репликой
соответственно.

### Kafka Events Bus

Очередь сообщений в лице Kafka + Zookeeper. Выполняет роль шины событий.

В данный момент продюсерлм сообщений выступает API Gateway Service. Потребителями инстансы News Service.

### News Service (Events Service)

Сервис для хранения/чтения пользовательских событий.

Подробнее о нем можно почитать в [отчете](../queues-n-cache/README.md)

По выполнению этого ДЗ, сервис сменил HTTP интерфейс на Websockets.

Прямой доступ извне к сервисам запрещен. Пользователя авторизует точка входа, после чего под API Gateway устанавливается
websocket соединение с выбранным инстансом News Service. Точка входа переключается в режим проксирования сообщений между
клиентом и сервисом новостей.

### Storekeeper

Сервис для обработки событий/новостей, полученных при чтении шины событий. Осуществляет сохранение событий в
персистентное хранилище, разогрев и актуализацию кэша.

### Redis

NoSQL DB, используется сервисом новостей, в качестве кэша, для быстрой выдачи списка новостей(событий) и быстрого
получения списка подписчиков.

### MongoDB

NoSQL база данных, используется сервисом новостей для персистентного хранения событий и подписчиков.

<a name="scaling"></a>

## Масштабирование сервиса новостей

Все сервисы в связке работают следующим образом:

1. Клиенты авторизуются и отправляют запросы к API Gateway;
2. Если запрос генерирует одно из пользовательских событий, то событие оформляется в сообщение и улетает в очередь (
   Kafka);
3. Из очереди сообщение достает сервис Storekeeper, проводит первичную обработку события, добавляет запись в
   персистентное хранилище и в кэш;
4. Клиент запрашивает websocket соединение для получения обновлений(новостей) пользователей, на которых он ранее
   подписался. API Gateway проводит аутентификацию пользователя;
5. По формуле `uid % N`, где uid - идентификатор пользователя, а N общее количество инстансов сервиса новостей,
   выбирается инстанс и с ним устанавливается websocket соединение. Как только соединение с сервисом новостей
   установленно, сервис API "апает" и переключает текущее соединение с пользователем в режим проксирования;
5. Установленное соединение помечается идентификатором пользователя и "кипится" на сервисе новостей.

В данный момент все сервисы новостей так же выступают потребителями очереди сообщений:

- вычитывает новость из очереди;
- по идентификатору автора события читает из кэша идентификаторы подписчиков;
- по идентификаторам подписчиков ищет у себя их активные websocket соединения. Если находит, отправляет сообщение, если
  нет, то отбрасывает событие.

Таким образом мы можем поднять сколь угодно много копий сервиса новостей. Читать события будут все сервисы, но
доставлять будут только те, у кого имеется активное соединение с подписчиком автора события.

> Была идея, в момент установки соединения подписываться через **mongo change streams** на события вставки документов, через `$match` отфильтровывая их по идентификатору подписчика, инициировавшего соединение.
> Но т.к. не был уверен в том, что это будет работать эффективнее, то за неимением времени на тестирование, отказался от данной затеи.

<a name="code"></a>

## Код сервисов

- [Код API Gateway](../../backend)
- [Код Сервиса Новостей](../../news)
- Код Websocket Клиента:
    1. [Service Provider](../../frontend/src/app/services/news.service.ts)
    2. [Разбор сообщений](../../frontend/src/app/components/dashboard/dashboard.component.ts)

<a name="env-prepearings"></a>

## Подготовка окружения

1. Стартуем окружение командой

> make upFull

Или через
> sudo docker-compose -f docker-compose.standalone.yml -f docker-compose.news.yml -f docker-compose.infra.yml up --build -d

**Создаем учётку тестера**

Можно через форму регистрации [http://127.0.0.1:8008/registration](http://127.0.0.1:8008/registration)

Можно curl запросом к API Gateway:

```
curl -XPOST http://127.0.0.1:8007/v1/auth/sign-up -d '{"username":"tester", "password":"1234567890", "passwordConfirm":"1234567890", "gender":"f"}'
```

Так же создаем учётку второго тестера:

```
curl -XPOST http://127.0.0.1:8007/v1/auth/sign-up -d '{"username":"tester2", "password":"1234567890", "passwordConfirm":"1234567890", "gender":"f"}'
```

Из ответа берем авторизационный токен, он нам понадобится для прямых запросов к API. Если так будет удобнее, то можно
запустить второй браузер, и осуществлять через него действия за второго тестера.

<a name="tests"></a>

## Тестирование

Авторизуемся под `tester`:

![Авторизация](login.png)

Увидим dashboard с пустой лентой новостей:

![пустой список](empty-list-gui.png)

Заглянем в консоль браузера и убедимся, что websocket соединение было установленно, и на инициализации мы получили
пустой список новостей:

![пустой список - console](empty-list-console.png)

Подпишемся на обновления пользователя `tester2`:

![подпишемся на обновления](subscribe.png)

Авторизуемся под пользователем `tester2`:

> curl -XPOST http://127.0.0.1:8007/v1/auth/sign-in -d '{"username":"tester2", "password":"1234567890"}'

В ответ получим:

```json
{
  "object": "token",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJleHAiOjE2MTU3MjUxMTQsImlhdCI6MTYxNTcyMTUxNCwiaXNzIjoiaGEtYmFja2VuZCJ9.0MLQtNjrpGyTf_gaWWbsoxN1gr_mxMWmLgCEcBfD_Ls",
  "userId": 4,
  "username": "tester2",
  "expires_at": 1615725114
}
```

Данное действие испустит событие `login`, которое будет отправлено всем активным подписчикам `tester2`

Проверим список новостей и консоль под `tester`:

![login event](login-event-gui.png)
![login event](login-event-console.png)

Видим что прилетело событие от пользователя, на которого мы подписались.

Теперь от имени `tester2` подпишемся на пользователя `janitor`:
> curl -XPOST http://127.0.0.1:8007/v1/friends/1  -H "Authorization:Bearer Токен-полученный-при-запросе-авторизации"

![подписываемся от tester2](follow.png)

И осуществляем сброс пользовательской сессии под `tester2`:
> curl -XPOST http://127.0.0.1:8007/v1/auth/sign-out  -H "Authorization:Bearer Токен-полученный-при-запросе-авторизации"

Смотрим в консоль и на список событий:
![](3-events-gui.png)
![](3-events-console.png)

Обновим страницу и проверим, что при повторной установке соединения мы получим полный список новостей:
![](full-list-console.png)

<a name="total"></a>

## Выводы

На выходе получили сервис, который может держать большое количество соединений и оперативно отдавать сообщения с
минимальными задержками.

Большим минусом текущей реализации является установка и поддержание прокси соединения между Api Gateway и сервисом
новостей.

Сервис новостей оптимизирован под работу с большим количеством websocket соединений, но точка входа под это никак не
заточена, и легко сложится по той же памяти на большом количестве открытых коннектов.

Возможно, стоит вывести из под единой точки входа сервис новостей и websocket соединения. Ввести общий сервис
авторизации, выдающий JWT токен, под которым с клиента можно будет как осуществить авторизированный запрос к API
Gateway, так и запросить websocket соединение с сервисом новостей. В качестве фронт-балансира для инстансов сервиса
новостей, можно прикрутить тот же nginx.
